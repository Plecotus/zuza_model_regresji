}
?ggplot
help(package="ggplot2")
x <- seq(0,40, .1)
# Set lambda
lambda <-.2
# Calculate theoretical mean
theoretical_mean <- 1/lambda
#Plot the distribution and the theoretical mean
plot(x, dexp(x,lambda), type = "l", lwd=2, ylab="Density", main = "Exponential distribution with lamdba = .2")
abline(v = theoretical_mean, col = "red", lwd=2)
set.seed(58698)
# Set the number of simulation
n_sim <- 1000
# Set number of observation in a single draw
n <- 40
# Create empty vector for averages
averages <- rep(NA, n_sim)
## Draw the observations from exponential distribuition,
## and calculate the mean for every draw. Assign it to
## following indices in the averages variable
for(i in 1:n_sim){
averages[i] <-mean(rexp(n, lambda))
}
hist(averages, main = " Histogram of simulated averages", xlab = "Average")
qqnorm(averages)
qqline(averages)
set.seed(5868)
# Set the number of simulation
n_sim <- 1000
# Set number of observation in a single draw
n <- 40
# Create empty vector for averages
averages <- rep(NA, n_sim)
## Draw the observations from exponential distribuition,
## and calculate the mean for every draw. Assign it to
## following indices in the averages variable
for(i in 1:n_sim){
averages[i] <-mean(rexp(n, lambda))
}
hist(averages, main = " Histogram of simulated averages", xlab = "Average")
qqline(averages)
qqline(averages)
qqnorm(averages)
qqline(averages)
set.seed(5868)
n_sim <- 10000
# Set number of observation in a single draw
n <- 40
# Create empty vector for averages
averages <- rep(NA, n_sim)
## Draw the observations from exponential distribuition,
## and calculate the mean for every draw. Assign it to
## following indices in the averages variable
for(i in 1:n_sim){
averages[i] <-mean(rexp(n, lambda))
}
```
hist(averages, main = " Histogram of simulated averages", xlab = "Average")
## Plot the sample quantiles vs. theoretical quantiles
qqnorm(averages)
qqline(averages)
hist(averages, main = " Histogram of simulated averages", xlab = "Average")
set.seed(5868)
# Set the number of simulation
n_sim <- 100000
# Set number of observation in a single draw
n <- 40
# Create empty vector for averages
averages <- rep(NA, n_sim)
for(i in 1:n_sim){
averages[i] <-mean(rexp(n, lambda))
}
hist(averages, main = " Histogram of simulated averages", xlab = "Average")
## Plot the sample quantiles vs. theoretical quantiles
qqnorm(averages)
qqline(averages)
set.seed(5868)
# Set the number of simulation
n_sim <- 1000000
# Set number of observation in a single draw
n <- 40
# Create empty vector for averages
averages <- rep(NA, n_sim)
## Draw the observations from exponential distribuition,
## and calculate the mean for every draw. Assign it to
## following indices in the averages variable
for(i in 1:n_sim){
averages[i] <-mean(rexp(n, lambda))
}
hist(averages, main = " Histogram of simulated averages", xlab = "Average")
## Plot the sample quantiles vs. theoretical quantiles
qqnorm(averages)
qqline(averages)
set.seed(5868)
# Set the number of simulation
n_sim <- 1000
# Set number of observation in a single draw
n <- 40
# Create empty vector for averages
averages <- rep(NA, n_sim)
## Draw the observations from exponential distribuition,
## and calculate the mean for every draw. Assign it to
## following indices in the averages variable
for(i in 1:n_sim){
averages[i] <-mean(rexp(n, lambda))
}
hist(averages, main = " Histogram of simulated averages", xlab = "Average")
qqnorm(averages)
qqline(averages)
qnorm(rnorm(1000))
qqnorm(rnorm(1000))
x <- rnorm(1000)
qqnorm(x)
qqline(x)
set.seed(5868)
# Set the parameters for the simulation
n_sim <- 1000; n <-40; lambda <-.2
averages <- rep(NA, n_sim)
for(i in 1:n_sim){
averages[i] <-mean(rexp(n, lambda))
}
hist(averages, main = " Histogram of simulated averages", xlab = "Average")
abline(v = 1/lambda)
abline(v = 1/lambda, col="red")
hist(averages, main = " Histogram of simulated averages", xlab = "Average")
abline(v = 1/lambda, col="red") # Theoretical mean
abline(v = mean(averages), col - "blue")
abline(v = mean(averages), col = "blue")
set.seed(5868)
n_sim <- 1000; n <-40; lambda <-.2
# Create empty vector for averages
averages <- rep(NA, n_sim)
for(i in 1:n_sim){averages[i] <-mean(rexp(n, lambda))}
hist(averages, main = " Histogram of simulated averages", xlab = "Average")
abline(v = 1/lambda, col="red") # Theoretical mean
abline(v = mean(averages), col = "blue") #Empirical mean
set.seed(558)
n_sim <- 1000; n <-40; lambda <-.2
averages <- rep(NA, n_sim)
for(i in 1:n_sim){averages[i] <-mean(rexp(n, lambda))}
hist(averages, main = " Histogram of simulated averages", xlab = "Average")
abline(v = 1/lambda, col="red") # Theoretical mean
abline(v = mean(averages), col = "blue") #Empirical mean
sample_mean <- mean(averages)
qqnorm(averages)
qqline(averages)
qqline(averages, col = "red")
variance <- (averages-sum(averages)/length(averages))
variance <- sum(((averages-sum(averages))^2)/length(averages))
(averages-sum(averages))^2
average
averages
variance <- sum(((averages-mean(averages))^2)/length(averages))
sd(averages)*40
(1/lambda)/sqrt(40)
ac <- rep(NA, 40)
for(i in 1:n_sim){ac[i] <-mean(rexp(n, lambda))}
hist(ac)
iris$platki <- iris$Petal.Length*iris$Petal.Width
iris$dzialki <- iris$Sepal.Width*iris$Petal.Length/2
platki<-c(platki_set, platki_ver, platki_vir)
dzialki<-c(dzialki_set, dzialki_ver, dzialki_vir)
plot(tabela, col=tabela$gatunek)
tabela<-data.frame(dzialki, platki, gatunek)
latki_set<-(setosa$Petal.Length*setosa$Petal.Width)
platki_ver<-(versicolor$Petal.Length*versicolor$Petal.Width)
platki_vir<-(virginica$Petal.Length*virginica$Petal.Width)
dzialki_set<-((setosa$Sepal.Length*setosa$Sepal.Width)/2)
dzialki_ver<-((versicolor$Sepal.Length*versicolor$Sepal.Width)/2)
dzialki_vir<-((virginica$Sepal.Length*virginica$Sepal.Width)/2)
platki<-c(platki_set, platki_ver, platki_vir)
dzialki<-c(dzialki_set, dzialki_ver, dzialki_vir)
plat_dzial<-data.frame(platki, dzialki)
# 9. Narysuj wykres rozrzutu dla tych dwĂłch zmiennych, tak ĹĽeby rĂłĹĽne gatunki byĹ‚y wyrysowane innym kolorem.
# tutaj też by odpadło co nieco.
gatunek<-iris[,5]
tabela<-data.frame(dzialki, platki, gatunek)
# tutaj przez przydek wychodzi ci fajny wykres, przydatny przy eksplotacjach danych
# ale tylko jeden z nich jest tym właściwym
plot(tabela, col=tabela$gatunek)
dzial_plat<-c(dzialki, platki)
plot(dzial_plat, col=tabela$gatunek)
platki_set<-(setosa$Petal.Length*setosa$Petal.Width)
plot(iris$platki, iris$dzialki, col=iris$Species)
plot(iris$dzialki, iris$platki,  col=iris$Species)
gatsetosa<-iris[c(1:50),]
data(iris)
gatsetosa<-iris[c(1:50),]
# 4. Narysuj histogram dla zmiennej Sepal.Length i dorysuj na nim liniÄ™ oznaczajÄ…cÄ… medianÄ™ - tak, ĹĽeby byĹ‚a widoczna. Opisz osie x i y.
hist(iris$Sepal.Length, xlab="dlugosc", ylab="czestotliwosc")
# mediana
abline(v=(median(iris$Sepal.Length)))
# 5. Ile wartoĹ›ci zmiennej Petal.Width w tym podzbiorze jest wiÄ™ksze od 0.3
sum(iris$Petal.Width>0.3)
# 6. Narysuj wykres, skrzynka z wÄ…sami z podziaĹ‚em na gatunki.
boxplot(Sepal.Length~Species, data=iris, main="Dlugosci dzialek kielicha od gatunku", xlab="Gatunek", ylab="Dlugosc")
# 7. Dla kaĹĽdego gatunku wylicz Ĺ›redniÄ… i odchylenie standardowe.
lista<-iris[1:4]
setosa<-lista[c(1:50),]
versicolor<-lista[c(51:100),]
virginica<-lista[c(101:150),]
by(iris$Sepal.Length, iris$Species, sd)
by(iris$Sepal.Length, iris$Species, mean)
iris$platki <- iris$Petal.Length*iris$Petal.Width
iris$dzialki <- iris$Sepal.Width*iris$Petal.Length/2
plot(iris$dzialki, iris$platki,  col=iris$Species)
dzial_plat<-c(dzialki, platki)
plot(dzial_plat, col=tabela$gatunek)
plot(iris$platki,iris$dzialki  col=iris$Species)
plot(iris$platki,iris$dzialki,  col=iris$Species)
iris$platki <- iris$Petal.Length*iris$Petal.Width/2
iris$dzialki <- iris$Sepal.Width*iris$Petal.Length
plot(iris$platki,iris$dzialki,  col=iris$Species)
iris$platki <- iris$Petal.Length*iris$Petal.Width
iris$dzialki <- iris$Sepal.Width*iris$Petal.Length/2
plot(iris$dzialki, iris$platki,  col=iris$Species)
cor(dzialki_set, platki_set)
data(iris)
# 2.Ile obserwacji i jakiego typu zmienne zostały zmierzone.
# tu mi brakuje funkcji, która to sprawdza i informacji czy to dane numeryczne,
# tekstowe, logiczen etc.
# 3. MOżna się pokusić o bardziej elastyczną formę w specyfikacji rzędów
# iris$Species =="setosa", ale bardzo dobre użycie przecinka.
gatsetosa<-iris[c(1:50),]
# 4. Spoko
hist(iris$Sepal.Length, xlab="dlugosc", ylab="czestotliwosc")
# mediana
abline(v=(median(iris$Sepal.Length)))
# 5. Świetnie, można by to jeszcze skondensować, albo wykorzystać właściwość,
# że TRUE == 1 i zsumować wektor warosci logicznych.
Petal.Width<-which(iris$Petal.Width>0.3)
length(Petal.Width)
# 6. Narysuj wykres, skrzynka z wÄ…sami z podziaĹ‚em na gatunki.
boxplot(Sepal.Length~Species, data=iris, main="Dlugosci dzialek kielicha od gatunku", xlab="Gatunek", ylab="Dlugosc")
# @ Ewa - miałaś o jeden nawias za dużo na końcu
# 7. Dla kaĹĽdego gatunku wylicz Ĺ›redniÄ… i odchylenie standardowe.
## NO tutaj to już dziki zachód. Wrzucasz wszystkie zmienne do jednego wora.
# To tak jakby wrzucić wzrost, wagę, wiek do jednego pudła i spróbowac opisać
# to jedną liczbą. Nie da się. Wystarczyło zrobić to dla jednej wybrannej zmiennej.
# Nie pisałem przecież, że wszystko musi się tu znaleźć
lista<-iris[1:4]
setosa<-lista[c(1:50),]
versicolor<-lista[c(51:100),]
virginica<-lista[c(101:150),]
species_set<-c(setosa$Sepal.Length,setosa$Sepal.Width, setosa$Petal.Length, setosa$Petal.Width)
species_ver<-c(versicolor$Sepal.Length,versicolor$Sepal.Width, versicolor$Petal.Length, versicolor$Petal.Width)
species_vir<-c(virginica$Sepal.Length,virginica$Sepal.Width, virginica$Petal.Length, virginica$Petal.Width)
sd(species_set)
sd(species_ver)
sd(species_vir)
mean(species_set)
mean(species_ver)
mean(species_vir)
# 8. StwĂłrz dwie nowe zmienne zawierajÄ…ce powierzchniÄ™ kwadratowych pĹ‚atkĂłw i trĂłjkÄ…tnych dziaĹ‚ek kielicha.
# a można było do razu robić to w tabeli iris i odpada z8-9 linijek kodu.
platki_set<-(setosa$Petal.Length*setosa$Petal.Width)
platki_ver<-(versicolor$Petal.Length*versicolor$Petal.Width)
platki_vir<-(virginica$Petal.Length*virginica$Petal.Width)
dzialki_set<-((setosa$Sepal.Length*setosa$Sepal.Width)/2)
dzialki_ver<-((versicolor$Sepal.Length*versicolor$Sepal.Width)/2)
dzialki_vir<-((virginica$Sepal.Length*virginica$Sepal.Width)/2)
platki<-c(platki_set, platki_ver, platki_vir)
dzialki<-c(dzialki_set, dzialki_ver, dzialki_vir)
plat_dzial<-data.frame(platki, dzialki)
gatunek<-iris[,5]
tabela<-data.frame(dzialki, platki, gatunek)
plot(tabela, col=tabela$gatunek)
plot(iris$dzialki, iris$platki,  col=iris$Species)
plot(iris$dzialki, iris$platki,  col=iris$Species)
plot(iris$dzialki, iris$platki,  col=iris$Species)
cor(dzialki_set, platki_set)
cor(dzialki_ver, platki_ver)
cor(dzialki_vir, platki_vir)
data(iris)
# 3. MOżna się pokusić o bardziej elastyczną formę
# 4. Narysuj histogram dla zmiennej Sepal.Length i dorysuj na nim liniÄ™ oznaczajÄ…cÄ… medianÄ™ - tak, ĹĽeby byĹ‚a widoczna. Opisz osie x i y.
hist(iris$Sepal.Length, xlab="dlugosc", ylab="czestotliwosc")
# mediana
abline(v=(median(iris$Sepal.Length)))
# 5. Ile wartoĹ›ci zmiennej Petal.Width w tym podzbiorze jest wiÄ™ksze od 0.3
sum(iris$Petal.Width>0.3)
# 6. Narysuj wykres, skrzynka z wÄ…sami z podziaĹ‚em na gatunki.
boxplot(Sepal.Length~Species, data=iris, main="Dlugosci dzialek kielicha od gatunku", xlab="Gatunek", ylab="Dlugosc")
# 7. Dla kaĹĽdego gatunku wylicz Ĺ›redniÄ… i odchylenie standardowe.
# można to było skrócić do 2 linijek
by(iris$Sepal.Length, iris$Species, sd)
by(iris$Sepal.Length, iris$Species, mean)
# 8. StwĂłrz dwie nowe zmienne zawierajÄ…ce powierzchniÄ™ kwadratowych pĹ‚atkĂłw i trĂłjkÄ…tnych dziaĹ‚ek kielicha.
iris$platki <- iris$Petal.Length*iris$Petal.Width
iris$dzialki <- iris$Sepal.Width*iris$Petal.Length/2
# 9. Narysuj wykres rozrzutu dla tych dwĂłch zmiennych, tak ĹĽeby rĂłĹĽne gatunki byĹ‚y wyrysowane innym kolorem.
plot(iris$dzialki, iris$platki,  col=iris$Species)
# 10. Wylicz korelacje dla poszczegolnych gatunkow i wskaz gatunek, ktory na wykresie tworzy najnizsza chmure punktow.
## I tutaj trzeba by pozamieniać na odwołania do tabeli iris i by grało.
cor(dzialki_ver, platki_ver)
cor(dzialki_vir, platki_vir)
# Najnizsza chmure punktow tworzy gatunek setosa.
cor(dzialki_set, platki_set)
gatsetosa<-iris[c(1:50),]
plot(dzial_plat, col=tabela$gatunek)
plot(tabela, col=tabela$gatunek)
install.packages("caret")
install.packages("AppliedPredictiveModeling")
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(1000)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
hist(training$Superplasticizer)
hist(log(training$Superplasticizer))
hist(log(training$Superplasticizer +1 ))
hist(log(training$Superplasticizer  ))
any(training$Superplasticizer == 0)
hist(log(training$Superplasticizer +1))
training$Superplasticizer +1)
training$Superplasticizer +1
any(training$Superplasticizer < 0)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
?grepl
columns <- grepl("^IL",names(training)))
columns <- grepl("^IL",names(training))
columns
training <- training[,columns]
preproc <- preProcess(training, method = "pca", pcaComp = 8)
dataePC <- predict(preproc, training)
dataePC
training
trainPC <- predict(preproc, training)
testing <- testing[,columns]
trainPC <- predict(preproc, training)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
columns <- grepl("^IL",names(training))
columns <- grepl("^IL",names(training))
training <- training[,c(TRUE,columns)]
testing <- testing[,c(TRUE,columns)]
preproc <- preProcess(training, method = "pca", pcaComp = 8)
preproc <- preProcess(trainin[,-1], method = "pca", pcaComp = 8)
preproc <- preProcess(training[,-1], method = "pca", pcaComp = 8)
trainPC <- predict(preproc, training)
trainPC <- predict(preproc, training[,-1])
modelFit <-train(training$diagnosis~., method = "glm", data = trainPC)
testPC <- predict(preproc, testing[,-1])
confusionMatrix(testing$diagnosis, predict(modelFit, testPC))
preproc <- preProcess(training[,-1], method = "pca", pcaComp = 9)
trainPC <- predict(preproc, training[,-1])
modelFit <-train(training$diagnosis~., method = "glm", data = trainPC)
testPC <- predict(preproc, testing[,-1])
confusionMatrix(testing$diagnosis, predict(modelFit, testPC))
preproc <- preProcess(training[,-1], method = "pca", pcaComp = 12)
trainPC <- predict(preproc, training[,-1])
modelFit <-train(training$diagnosis~., method = "glm", data = trainPC)
testPC <- predict(preproc, testing[,-1])
confusionMatrix(testing$diagnosis, predict(modelFit, testPC))
?colSum
?colSums
?lm
?predict
?dgamma
M <- matrix(rbinom(55000*1000), 55000, 1000)
?rbinom
M <- matrix(rbinom(55000*1000,1), 55000, 1000)
M <- matrix(rbinom(55000*1000,1, .5), 55000, 1000)
M <- as.data.frame(M)
M$kwadrat <- as.factor(sample(paste0("A",1:100), 55000, replace = T))
View(M)
m[4,35000]
M[4,35000]
M[4,999]
head(M$kwadrat)
data(ToothGrowth)
str(ToothGrowth)
?ToothGrowth
by(ToothGrowth$len, ToothGrowth[,2:3], summary)
library(ggplot2)
g <- ggplot(ToothGrowth, aes(x=len))
g + stat_boxplot()
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(x=len, y = c(supp, dose)))
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(x=len, y=1))
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(x=len, y=5))
g <- ggplot(ToothGrowth, aes(x=len, y=dose))
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(x=len, y=supp))
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes( y=len))
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(x =1, y=len))
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(x =c(factor(dose), supp), y=len))
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(x =factor(paste(dose, supp), y=len))
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(x =factor(paste(dose, supp), y=len))
)
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(x = factor(paste(dose, supp), y =len)))
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(x = factor(dose) y =len)))
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(factor(dose), len)))
g + geom_boxplot()
g <- ggplot(ToothGrowth, aes(factor(dose), len))
g + geom_boxplot()
g + geom_boxplot() + facet_grid(.~supp)
g + geom_boxplot() + facet_grid(.~supp)+
labs(list(x="Dose", y="Tooth length [mm]"))
p_boundary <- .05/3
dose_0.5 <- ToothGrowth[ToothGrowth$dose == .5,]
dose_0.5 <- ToothGrowth[ToothGrowth$dose == .5,]
dose_1 <- ToothGrowth[ToothGrowth$dose == 1,]
dose_2<- ToothGrowth[ToothGrowth$dose == 2,]
t.test(len ~ supp, data = dose_0.5)
t.test(len ~ supp, data = dose_1)
t.test(len ~ supp, data = dose_2)
setwd("~/R/zuza_model_regresji")
bipniecia <- read.csv2("reg_model_Zuza.csv", sep = ";", header = T)
bipniecia.lm <- with(bipniecia, lm(temperature~average_BPM))
summary(bipniecia.lm)
predict(bipniecia.lm) [2:4]
predict(bipniecia.lm)
with(bipniecia, plot(temperature~average_BPM, type="l", las = 1))
?predict
predict(bipniecia.lm, 25)
y2 <- predict(bipniecia.lm, list(temperature=x2), int="c")
x2 <- seq(0, 50, 2)
y2 <- predict(bipniecia.lm, list(temperature=x2), int="c")
with(bipniecia, plot(temperature~average_BPM, type="p", las = 1))
bipniecia$bmproot <- sqrt(bipniecia$average_BPM)
bipniecia.lm <- with(bipniecia, lm(temperature~average_BPM + bmproot))
with(bipniecia, plot(temperature~average_BPM, type="l", las = 1))
lines(bipniecia$temperature, bipniecia.lm$predict)
with(bipniecia, plot(temperature~average_BPM, type="l", las = 1))
with(bipniecia, plot(temperature~average_BPM, type="p", las = 1))
lines(bipniecia$temperature, bipniecia.lm$predict)
lines(bipniecia$temperature, bipniecia.lm$fitted)
?nlm
bipniecia.lm <-nls(temperature~average_BPM, data = bipniecia)
bipniecia$log <- log(bipniecia$average_BPM)
bipniecia.lm <-nls(temperature ~ average_BPM +log, data = bipniecia)
bipniecia.lm <-lm(temperature ~ average_BPM +log, data = bipniecia)
with(bipniecia, plot(temperature~average_BPM, type="l", las = 1))
with(bipniecia, plot(temperature~average_BPM, type="p", las = 1))
lines(bipniecia$temperature, bipniecia.lm$fitted.values)
bipniecia$log <- (bipniecia$average_BPM)^2
bipniecia.lm <-lm(temperature ~ average_BPM +log, data = bipniecia)
with(bipniecia, plot(temperature~average_BPM, type="p", las = 1))
lines(bipniecia$temperature, bipniecia.lm$fitted.values)
bipniecia.lm <-lm(temperature ~ average_BPM +log, data = bipniecia)
lines(bipniecia$temperature, bipniecia.lm$fitted.values)
bipniecia.lm <-lm(temperature ~ average_BPM , data = bipniecia)
with(bipniecia, plot(temperature~average_BPM, type="p", las = 1))
lines(bipniecia$temperature, bipniecia.lm$fitted.values)
bipniecia.lm <-lm(temperature ~ average_BPM , data = bipniecia)
with(bipniecia, plot(temperature~average_BPM, type="p", las = 1))
lines(bipniecia$temperature, bipniecia.lm$fitted.values)
bipniecia <- read.csv2("reg_model_Zuza.csv", sep = ";", header = T)
bipniecia.lm <-lm(temperature ~ average_BPM , data = bipniecia)
with(bipniecia, plot(temperature~average_BPM, type="p", las = 1))
lines(bipniecia$temperature, bipniecia.lm$fitted.values)
lines(bipniecia.lm$fitted.values, bipniecia$temperature)
summary(bipniecia.lm)
bipniecia <- read.csv2("reg_model_Zuza.csv", sep = ";", header = T)
bipniecia.lm <-lm(temperature ~ average_BPM , data = bipniecia)
with(bipniecia, plot(temperature~average_BPM, type="p", las = 1))
lines(bipniecia$average_BPM, bipniecia.lm$fitted.values)
bipniecia$log <- (bipniecia$average_BPM)^2
bipniecia$log <- (bipniecia$average_BPM)^2
bipniecia.lm <-lm(temperature ~ average_BPM +log, data = bipniecia)
lines(bipniecia$average_BPM, bipniecia.lm$fitted.values)
bipniecia$log <- log(bipniecia$average_BPM)
bipniecia.lm <-lm(temperature ~ average_BPM +log, data = bipniecia)
with(bipniecia, plot(temperature~average_BPM, type="p", las = 1))
lines(bipniecia$average_BPM, bipniecia.lm$fitted.values)
summary(bipniecia.lm)
bipniecia.lm <-lm(temperature ~ log, data = bipniecia)
with(bipniecia, plot(temperature~average_BPM, type="p", las = 1))
lines(bipniecia$average_BPM, bipniecia.lm$fitted.values)
t.test(len ~ supp, data = dose_0.5)
t.test(len ~ supp, data = dose_1)
t.test(len ~ supp, data = dose_2)
data(ToothGrowth)
library(ggplot2)
str(ToothGrowth)
by(ToothGrowth$len, ToothGrowth[,2:3], summary)
# Creates boxplot for len varibale grouped by dose
g <- ggplot(ToothGrowth, aes(factor(dose), len))
# Plots boxplots grouped by supp
g + geom_boxplot() + facet_grid(.~supp)+
labs(list(x="Dose", y="Tooth length [microns]"))
p_boundary <- .05/3
dose_0.5 <- ToothGrowth[ToothGrowth$dose == .5,]
dose_1 <- ToothGrowth[ToothGrowth$dose == 1,]
dose_2<- ToothGrowth[ToothGrowth$dose == 2,]
t.test(len ~ supp, data = dose_0.5)
t.test(len ~ supp, data = dose_1)
t.test(len ~ supp, data = dose_2)
p_boundary
